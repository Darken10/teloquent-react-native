/**
 * Classe Query pour construire des requêtes SQL de manière fluide
 */
import { DB } from './DB';
import { Collection } from './Collection';
import { Model } from './Model';
import { WhereCondition, OrderByClause, WhereOperator } from '../types';

export class Query<M extends Model = Model> {
  protected _table: string;
  protected _modelClass: typeof Model;
  protected _selects: string[] = ['*'];
  protected _wheres: WhereCondition[] = [];
  protected _orders: OrderByClause[] = [];
  protected _limit: number | null = null;
  protected _offset: number | null = null;
  protected _joins: string[] = [];
  protected _groups: string[] = [];
  protected _havings: WhereCondition[] = [];
  protected _relations: string[] = [];

  /**
   * Constructeur de Query
   */
  constructor(modelClass: typeof Model, table: string) {
    this._modelClass = modelClass;
    this._table = table;
  }

  /**
   * Spécifier les colonnes à sélectionner
   */
  public select(...columns: string[]): this {
    this._selects = columns.length > 0 ? columns : ['*'];
    return this;
  }

  /**
   * Ajouter une clause WHERE
   */
  public where(column: string, operator: WhereOperator | string | number | boolean | null | undefined, value?: string | number | boolean | null | undefined | (string | number | boolean | null | undefined)[], boolean: 'and' | 'or' = 'and'): this {
    // Gérer le cas où l'opérateur est omis (where('column', value))
    if (value === undefined) {
      value = operator;
      operator = '=' as WhereOperator;
    }

    this._wheres.push({
      column,
      operator: operator as WhereOperator,
      value,
      boolean
    });

    return this;
  }

  /**
   * Ajouter une clause WHERE avec OR
   */
  public orWhere(column: string, operator: WhereOperator | string | number | boolean | null | undefined, value?: string | number | boolean | null | undefined | (string | number | boolean | null | undefined)[]): this {
    return this.where(column, operator, value, 'or');
  }

  /**
   * Ajouter une clause WHERE IN
   */
  public whereIn(column: string, values: (string | number | boolean | null | undefined)[], boolean: 'and' | 'or' = 'and'): this {
    this._wheres.push({
      column,
      operator: 'IN',
      value: values,
      boolean
    });

    return this;
  }

  /**
   * Ajouter une clause WHERE NOT IN
   */
  public whereNotIn(column: string, values: (string | number | boolean | null | undefined)[], boolean: 'and' | 'or' = 'and'): this {
    this._wheres.push({
      column,
      operator: 'NOT IN',
      value: values,
      boolean
    });

    return this;
  }

  /**
   * Ajouter une clause WHERE NULL
   */
  public whereNull(column: string, boolean: 'and' | 'or' = 'and'): this {
    this._wheres.push({
      column,
      operator: 'NULL',
      value: null,
      boolean
    });

    return this;
  }

  /**
   * Ajouter une clause WHERE NOT NULL
   */
  public whereNotNull(column: string, boolean: 'and' | 'or' = 'and'): this {
    this._wheres.push({
      column,
      operator: 'NOT NULL',
      value: null,
      boolean
    });

    return this;
  }

  /**
   * Ajouter une clause ORDER BY
   */
  public orderBy(column: string, direction: 'asc' | 'desc' = 'asc'): this {
    this._orders.push({
      column,
      direction
    });

    return this;
  }

  /**
   * Ajouter une clause LIMIT
   */
  public limit(limit: number): this {
    this._limit = limit;
    return this;
  }

  /**
   * Ajouter une clause OFFSET
   */
  public offset(offset: number): this {
    this._offset = offset;
    return this;
  }

  /**
   * Ajouter une clause JOIN
   */
  public join(table: string, first: string, operator: string, second: string): this {
    this._joins.push(`JOIN ${table} ON ${first} ${operator} ${second}`);
    return this;
  }

  /**
   * Ajouter une clause LEFT JOIN
   */
  public leftJoin(table: string, first: string, operator: string, second: string): this {
    this._joins.push(`LEFT JOIN ${table} ON ${first} ${operator} ${second}`);
    return this;
  }

  /**
   * Ajouter une clause GROUP BY
   */
  public groupBy(...columns: string[]): this {
    this._groups.push(...columns);
    return this;
  }

  /**
   * Ajouter une clause HAVING
   */
  public having(column: string, operator: WhereOperator | string | number | boolean | null | undefined, value?: string | number | boolean | null | undefined | (string | number | boolean | null | undefined)[], boolean: 'and' | 'or' = 'and'): this {
    // Gérer le cas où l'opérateur est omis
    if (value === undefined) {
      value = operator;
      operator = '=';
    }

    this._havings.push({
      column,
      operator: operator as WhereOperator,
      value,
      boolean
    });

    return this;
  }

  /**
   * Spécifier les relations à charger avec eager loading
   */
  public with(...relations: string[]): this {
    this._relations.push(...relations);
    return this;
  }

  /**
   * Construire la requête SQL
   */
  protected buildQuery(): { sql: string; params: (string | number | boolean | null | undefined)[] } {
    let sql = `SELECT ${this._selects.join(', ')} FROM ${this._table}`;
    const params: (string | number | boolean | null | undefined)[] = [];

    // Ajouter les JOINs
    if (this._joins.length > 0) {
      sql += ' ' + this._joins.join(' ');
    }

    // Ajouter les WHEREs
    if (this._wheres.length > 0) {
      sql += ' WHERE';
      
      this._wheres.forEach((where, index) => {
        const connector = index === 0 ? ' ' : ` ${where.boolean} `;
        
        if (where.operator === 'IN' || where.operator === 'NOT IN') {
          const placeholders = Array(where.value.length).fill('?').join(', ');
          sql += `${connector}${where.column} ${where.operator} (${placeholders})`;
          params.push(...where.value);
        } else if (where.operator === 'NULL') {
          sql += `${connector}${where.column} IS NULL`;
        } else if (where.operator === 'NOT NULL') {
          sql += `${connector}${where.column} IS NOT NULL`;
        } else if (where.operator === 'BETWEEN') {
          sql += `${connector}${where.column} BETWEEN ? AND ?`;
          params.push(where.value[0], where.value[1]);
        } else if (where.operator === 'NOT BETWEEN') {
          sql += `${connector}${where.column} NOT BETWEEN ? AND ?`;
          params.push(where.value[0], where.value[1]);
        } else {
          sql += `${connector}${where.column} ${where.operator} ?`;
          params.push(where.value);
        }
      });
    }

    // Ajouter les GROUP BYs
    if (this._groups.length > 0) {
      sql += ` GROUP BY ${this._groups.join(', ')}`;
    }

    // Ajouter les HAVINGs
    if (this._havings.length > 0) {
      sql += ' HAVING';
      
      this._havings.forEach((having, index) => {
        const connector = index === 0 ? ' ' : ` ${having.boolean} `;
        sql += `${connector}${having.column} ${having.operator} ?`;
        params.push(having.value);
      });
    }

    // Ajouter les ORDER BYs
    if (this._orders.length > 0) {
      const orderClauses = this._orders.map(order => `${order.column} ${order.direction}`);
      sql += ` ORDER BY ${orderClauses.join(', ')}`;
    }

    // Ajouter LIMIT et OFFSET
    if (this._limit !== null) {
      sql += ` LIMIT ?`;
      params.push(this._limit);
      
      if (this._offset !== null) {
        sql += ` OFFSET ?`;
        params.push(this._offset);
      }
    }

    return { sql, params };
  }

  /**
   * Exécuter la requête et retourner tous les résultats
   */
  public async get(): Promise<Collection<M>> {
    const { sql, params } = this.buildQuery();
    const results = await DB.select(sql, params);
    
    // Créer des instances de modèle à partir des résultats
    const models = results.map(result => {
      const model = new this._modelClass() as M;
      model.fill(result);
      (model as any).exists = true; // Utilisation de cast pour accéder à la propriété protégée
      return model;
    });

    // Créer une collection
    const collection = new Collection<M>(models);

    // Charger les relations si nécessaire
    if (this._relations.length > 0) {
      await this.loadRelations(collection);
    }

    return collection;
  }

  /**
   * Exécuter la requête et retourner le premier résultat
   */
  public async first(): Promise<M | null> {
    const original = this._limit;
    this.limit(1);
    
    const results = await this.get();
    this._limit = original;
    
    return results.first() || null;
  }

  /**
   * Trouver un modèle par sa clé primaire
   */
  public async find(id: number | string): Promise<M | null> {
    return this.where('id', id).first();
  }

  /**
   * Compter le nombre de résultats
   */
  public async count(column: string = '*'): Promise<number> {
    const original = [...this._selects];
    this._selects = [`COUNT(${column}) as count`];
    
    const { sql, params } = this.buildQuery();
    const results = await DB.select(sql, params);
    
    this._selects = original;
    
    return results[0]?.count || 0;
  }

  /**
   * Vérifier si des résultats existent
   */
  public async exists(): Promise<boolean> {
    return (await this.count()) > 0;
  }

  /**
   * Mettre à jour des enregistrements
   */
  public async update(data: Record<string, string | number | boolean | null | undefined | Date | object | (string | number | boolean | null | undefined | Date | object)[]>): Promise<number> {
    const { sql: whereSql, params: whereParams } = this.buildWhereClause();
    return DB.update(this._table, data, whereSql, whereParams);
  }

  /**
   * Supprimer des enregistrements
   */
  public async delete(): Promise<number> {
    const { sql: whereSql, params: whereParams } = this.buildWhereClause();
    return DB.delete(this._table, whereSql, whereParams);
  }

  /**
   * Construire uniquement la clause WHERE
   */
  protected buildWhereClause(): { sql: string; params: (string | number | boolean | null | undefined)[] } {
    let sql = '1=1'; // Clause par défaut pour éviter les erreurs si aucun WHERE
    const params: (string | number | boolean | null | undefined)[] = [];

    if (this._wheres.length > 0) {
      sql = '';
      
      this._wheres.forEach((where, index) => {
        const connector = index === 0 ? '' : ` ${where.boolean} `;
        
        if (where.operator === 'IN' || where.operator === 'NOT IN') {
          const placeholders = Array(where.value.length).fill('?').join(', ');
          sql += `${connector}${where.column} ${where.operator} (${placeholders})`;
          params.push(...where.value);
        } else if (where.operator === 'NULL') {
          sql += `${connector}${where.column} IS NULL`;
        } else if (where.operator === 'NOT NULL') {
          sql += `${connector}${where.column} IS NOT NULL`;
        } else if (where.operator === 'BETWEEN') {
          sql += `${connector}${where.column} BETWEEN ? AND ?`;
          params.push(where.value[0], where.value[1]);
        } else if (where.operator === 'NOT BETWEEN') {
          sql += `${connector}${where.column} NOT BETWEEN ? AND ?`;
          params.push(where.value[0], where.value[1]);
        } else {
          sql += `${connector}${where.column} ${where.operator} ?`;
          params.push(where.value);
        }
      });
    }

    return { sql, params };
  }

  /**
   * Charger les relations pour une collection de modèles
   */
  protected async loadRelations(collection: Collection<M>): Promise<void> {
    if (collection.isEmpty()) {
      return;
    }

    for (const relation of this._relations) {
      const relationName = relation.split('.')[0];
      
      // Vérifier si la collection n'est pas vide et si la méthode de relation existe
      const firstModel = collection.first();
      if (!firstModel || typeof firstModel[relationName] !== 'function') {
        console.warn(`La relation "${relationName}" n'existe pas sur le modèle ${this._modelClass.name}`);
        continue;
      }

      // Obtenir l'instance de relation
      const relationKey = relationName as keyof typeof firstModel;
      // Utiliser une signature de fonction spécifique au lieu de Function
      const relationFunction = firstModel[relationKey] as (...args: unknown[]) => unknown;
      const relationInstance = relationFunction.call(firstModel);
      
      // Charger la relation pour tous les modèles de la collection
      await relationInstance.loadForCollection(collection, relation);
    }
  }
} 
 
 
